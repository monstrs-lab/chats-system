// @generated by protoc-gen-es v1.4.2 with parameter "target=ts"
// @generated from file tech/monstrs/chats_system/core/v1alpha1/schema.tl.handshake.proto (package tech.monstrs.chats_system.core.v1alpha1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { TLConstructor } from "./schema.tl.crc32_pb.js";

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.BindAuthKeyInner
 */
export class BindAuthKeyInner extends Message<BindAuthKeyInner> {
  /**
   * @generated from field: optional string predicate_name = 1;
   */
  predicateName?: string;

  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.TLConstructor constructor = 2;
   */
  constructor$?: TLConstructor;

  /**
   * @generated from field: optional int64 nonce = 3;
   */
  nonce?: bigint;

  /**
   * @generated from field: optional int64 temp_auth_key_id = 4;
   */
  tempAuthKeyId?: bigint;

  /**
   * @generated from field: optional int64 perm_auth_key_id = 5;
   */
  permAuthKeyId?: bigint;

  /**
   * @generated from field: optional int64 temp_session_id = 6;
   */
  tempSessionId?: bigint;

  /**
   * @generated from field: optional int32 expires_at = 7;
   */
  expiresAt?: number;

  constructor(data?: PartialMessage<BindAuthKeyInner>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tech.monstrs.chats_system.core.v1alpha1.BindAuthKeyInner";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "predicate_name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "constructor", kind: "enum", T: proto3.getEnumType(TLConstructor), opt: true },
    { no: 3, name: "nonce", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 4, name: "temp_auth_key_id", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 5, name: "perm_auth_key_id", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 6, name: "temp_session_id", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 7, name: "expires_at", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BindAuthKeyInner {
    return new BindAuthKeyInner().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BindAuthKeyInner {
    return new BindAuthKeyInner().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BindAuthKeyInner {
    return new BindAuthKeyInner().fromJsonString(jsonString, options);
  }

  static equals(a: BindAuthKeyInner | PlainMessage<BindAuthKeyInner> | undefined, b: BindAuthKeyInner | PlainMessage<BindAuthKeyInner> | undefined): boolean {
    return proto3.util.equals(BindAuthKeyInner, a, b);
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLBindAuthKeyInner
 */
export class TLBindAuthKeyInner extends Message<TLBindAuthKeyInner> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.BindAuthKeyInner data2 = 1;
   */
  data2?: BindAuthKeyInner;

  constructor(data?: PartialMessage<TLBindAuthKeyInner>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tech.monstrs.chats_system.core.v1alpha1.TLBindAuthKeyInner";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data2", kind: "message", T: BindAuthKeyInner, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLBindAuthKeyInner {
    return new TLBindAuthKeyInner().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLBindAuthKeyInner {
    return new TLBindAuthKeyInner().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLBindAuthKeyInner {
    return new TLBindAuthKeyInner().fromJsonString(jsonString, options);
  }

  static equals(a: TLBindAuthKeyInner | PlainMessage<TLBindAuthKeyInner> | undefined, b: TLBindAuthKeyInner | PlainMessage<TLBindAuthKeyInner> | undefined): boolean {
    return proto3.util.equals(TLBindAuthKeyInner, a, b);
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.ClientDHInnerData
 */
export class ClientDHInnerData extends Message<ClientDHInnerData> {
  /**
   * @generated from field: optional string predicate_name = 1;
   */
  predicateName?: string;

  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.TLConstructor constructor = 2;
   */
  constructor$?: TLConstructor;

  /**
   * @generated from field: optional bytes nonce = 3;
   */
  nonce?: Uint8Array;

  /**
   * @generated from field: optional bytes server_nonce = 4;
   */
  serverNonce?: Uint8Array;

  /**
   * @generated from field: optional int64 retry_id = 5;
   */
  retryId?: bigint;

  /**
   * @generated from field: optional string g_b = 6;
   */
  gB?: string;

  constructor(data?: PartialMessage<ClientDHInnerData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tech.monstrs.chats_system.core.v1alpha1.ClientDHInnerData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "predicate_name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "constructor", kind: "enum", T: proto3.getEnumType(TLConstructor), opt: true },
    { no: 3, name: "nonce", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 4, name: "server_nonce", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 5, name: "retry_id", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 6, name: "g_b", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientDHInnerData {
    return new ClientDHInnerData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientDHInnerData {
    return new ClientDHInnerData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientDHInnerData {
    return new ClientDHInnerData().fromJsonString(jsonString, options);
  }

  static equals(a: ClientDHInnerData | PlainMessage<ClientDHInnerData> | undefined, b: ClientDHInnerData | PlainMessage<ClientDHInnerData> | undefined): boolean {
    return proto3.util.equals(ClientDHInnerData, a, b);
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLClientDHInnerData
 */
export class TLClientDHInnerData extends Message<TLClientDHInnerData> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.ClientDHInnerData data2 = 1;
   */
  data2?: ClientDHInnerData;

  constructor(data?: PartialMessage<TLClientDHInnerData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tech.monstrs.chats_system.core.v1alpha1.TLClientDHInnerData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data2", kind: "message", T: ClientDHInnerData, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLClientDHInnerData {
    return new TLClientDHInnerData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLClientDHInnerData {
    return new TLClientDHInnerData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLClientDHInnerData {
    return new TLClientDHInnerData().fromJsonString(jsonString, options);
  }

  static equals(a: TLClientDHInnerData | PlainMessage<TLClientDHInnerData> | undefined, b: TLClientDHInnerData | PlainMessage<TLClientDHInnerData> | undefined): boolean {
    return proto3.util.equals(TLClientDHInnerData, a, b);
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.DestroyAuthKeyRes
 */
export class DestroyAuthKeyRes extends Message<DestroyAuthKeyRes> {
  /**
   * @generated from field: optional string predicate_name = 1;
   */
  predicateName?: string;

  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.TLConstructor constructor = 2;
   */
  constructor$?: TLConstructor;

  constructor(data?: PartialMessage<DestroyAuthKeyRes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tech.monstrs.chats_system.core.v1alpha1.DestroyAuthKeyRes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "predicate_name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "constructor", kind: "enum", T: proto3.getEnumType(TLConstructor), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DestroyAuthKeyRes {
    return new DestroyAuthKeyRes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DestroyAuthKeyRes {
    return new DestroyAuthKeyRes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DestroyAuthKeyRes {
    return new DestroyAuthKeyRes().fromJsonString(jsonString, options);
  }

  static equals(a: DestroyAuthKeyRes | PlainMessage<DestroyAuthKeyRes> | undefined, b: DestroyAuthKeyRes | PlainMessage<DestroyAuthKeyRes> | undefined): boolean {
    return proto3.util.equals(DestroyAuthKeyRes, a, b);
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLDestroyAuthKeyOk
 */
export class TLDestroyAuthKeyOk extends Message<TLDestroyAuthKeyOk> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.DestroyAuthKeyRes data2 = 1;
   */
  data2?: DestroyAuthKeyRes;

  constructor(data?: PartialMessage<TLDestroyAuthKeyOk>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tech.monstrs.chats_system.core.v1alpha1.TLDestroyAuthKeyOk";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data2", kind: "message", T: DestroyAuthKeyRes, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLDestroyAuthKeyOk {
    return new TLDestroyAuthKeyOk().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLDestroyAuthKeyOk {
    return new TLDestroyAuthKeyOk().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLDestroyAuthKeyOk {
    return new TLDestroyAuthKeyOk().fromJsonString(jsonString, options);
  }

  static equals(a: TLDestroyAuthKeyOk | PlainMessage<TLDestroyAuthKeyOk> | undefined, b: TLDestroyAuthKeyOk | PlainMessage<TLDestroyAuthKeyOk> | undefined): boolean {
    return proto3.util.equals(TLDestroyAuthKeyOk, a, b);
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLDestroyAuthKeyNone
 */
export class TLDestroyAuthKeyNone extends Message<TLDestroyAuthKeyNone> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.DestroyAuthKeyRes data2 = 1;
   */
  data2?: DestroyAuthKeyRes;

  constructor(data?: PartialMessage<TLDestroyAuthKeyNone>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tech.monstrs.chats_system.core.v1alpha1.TLDestroyAuthKeyNone";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data2", kind: "message", T: DestroyAuthKeyRes, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLDestroyAuthKeyNone {
    return new TLDestroyAuthKeyNone().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLDestroyAuthKeyNone {
    return new TLDestroyAuthKeyNone().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLDestroyAuthKeyNone {
    return new TLDestroyAuthKeyNone().fromJsonString(jsonString, options);
  }

  static equals(a: TLDestroyAuthKeyNone | PlainMessage<TLDestroyAuthKeyNone> | undefined, b: TLDestroyAuthKeyNone | PlainMessage<TLDestroyAuthKeyNone> | undefined): boolean {
    return proto3.util.equals(TLDestroyAuthKeyNone, a, b);
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLDestroyAuthKeyFail
 */
export class TLDestroyAuthKeyFail extends Message<TLDestroyAuthKeyFail> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.DestroyAuthKeyRes data2 = 1;
   */
  data2?: DestroyAuthKeyRes;

  constructor(data?: PartialMessage<TLDestroyAuthKeyFail>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tech.monstrs.chats_system.core.v1alpha1.TLDestroyAuthKeyFail";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data2", kind: "message", T: DestroyAuthKeyRes, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLDestroyAuthKeyFail {
    return new TLDestroyAuthKeyFail().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLDestroyAuthKeyFail {
    return new TLDestroyAuthKeyFail().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLDestroyAuthKeyFail {
    return new TLDestroyAuthKeyFail().fromJsonString(jsonString, options);
  }

  static equals(a: TLDestroyAuthKeyFail | PlainMessage<TLDestroyAuthKeyFail> | undefined, b: TLDestroyAuthKeyFail | PlainMessage<TLDestroyAuthKeyFail> | undefined): boolean {
    return proto3.util.equals(TLDestroyAuthKeyFail, a, b);
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.PQInnerData
 */
export class PQInnerData extends Message<PQInnerData> {
  /**
   * @generated from field: optional string predicate_name = 1;
   */
  predicateName?: string;

  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.TLConstructor constructor = 2;
   */
  constructor$?: TLConstructor;

  /**
   * @generated from field: optional string pq = 3;
   */
  pq?: string;

  /**
   * @generated from field: optional string p = 4;
   */
  p?: string;

  /**
   * @generated from field: optional string q = 5;
   */
  q?: string;

  /**
   * @generated from field: optional bytes nonce = 6;
   */
  nonce?: Uint8Array;

  /**
   * @generated from field: optional bytes server_nonce = 7;
   */
  serverNonce?: Uint8Array;

  /**
   * @generated from field: optional bytes new_nonce = 8;
   */
  newNonce?: Uint8Array;

  /**
   * @generated from field: optional int32 dc = 9;
   */
  dc?: number;

  /**
   * @generated from field: optional int32 expires_in = 10;
   */
  expiresIn?: number;

  constructor(data?: PartialMessage<PQInnerData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tech.monstrs.chats_system.core.v1alpha1.PQInnerData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "predicate_name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "constructor", kind: "enum", T: proto3.getEnumType(TLConstructor), opt: true },
    { no: 3, name: "pq", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "p", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "q", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "nonce", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 7, name: "server_nonce", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 8, name: "new_nonce", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 9, name: "dc", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 10, name: "expires_in", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PQInnerData {
    return new PQInnerData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PQInnerData {
    return new PQInnerData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PQInnerData {
    return new PQInnerData().fromJsonString(jsonString, options);
  }

  static equals(a: PQInnerData | PlainMessage<PQInnerData> | undefined, b: PQInnerData | PlainMessage<PQInnerData> | undefined): boolean {
    return proto3.util.equals(PQInnerData, a, b);
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLPQInnerData
 */
export class TLPQInnerData extends Message<TLPQInnerData> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.PQInnerData data2 = 1;
   */
  data2?: PQInnerData;

  constructor(data?: PartialMessage<TLPQInnerData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tech.monstrs.chats_system.core.v1alpha1.TLPQInnerData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data2", kind: "message", T: PQInnerData, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLPQInnerData {
    return new TLPQInnerData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLPQInnerData {
    return new TLPQInnerData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLPQInnerData {
    return new TLPQInnerData().fromJsonString(jsonString, options);
  }

  static equals(a: TLPQInnerData | PlainMessage<TLPQInnerData> | undefined, b: TLPQInnerData | PlainMessage<TLPQInnerData> | undefined): boolean {
    return proto3.util.equals(TLPQInnerData, a, b);
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLPQInnerDataDc
 */
export class TLPQInnerDataDc extends Message<TLPQInnerDataDc> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.PQInnerData data2 = 1;
   */
  data2?: PQInnerData;

  constructor(data?: PartialMessage<TLPQInnerDataDc>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tech.monstrs.chats_system.core.v1alpha1.TLPQInnerDataDc";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data2", kind: "message", T: PQInnerData, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLPQInnerDataDc {
    return new TLPQInnerDataDc().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLPQInnerDataDc {
    return new TLPQInnerDataDc().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLPQInnerDataDc {
    return new TLPQInnerDataDc().fromJsonString(jsonString, options);
  }

  static equals(a: TLPQInnerDataDc | PlainMessage<TLPQInnerDataDc> | undefined, b: TLPQInnerDataDc | PlainMessage<TLPQInnerDataDc> | undefined): boolean {
    return proto3.util.equals(TLPQInnerDataDc, a, b);
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLPQInnerDataTemp
 */
export class TLPQInnerDataTemp extends Message<TLPQInnerDataTemp> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.PQInnerData data2 = 1;
   */
  data2?: PQInnerData;

  constructor(data?: PartialMessage<TLPQInnerDataTemp>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tech.monstrs.chats_system.core.v1alpha1.TLPQInnerDataTemp";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data2", kind: "message", T: PQInnerData, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLPQInnerDataTemp {
    return new TLPQInnerDataTemp().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLPQInnerDataTemp {
    return new TLPQInnerDataTemp().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLPQInnerDataTemp {
    return new TLPQInnerDataTemp().fromJsonString(jsonString, options);
  }

  static equals(a: TLPQInnerDataTemp | PlainMessage<TLPQInnerDataTemp> | undefined, b: TLPQInnerDataTemp | PlainMessage<TLPQInnerDataTemp> | undefined): boolean {
    return proto3.util.equals(TLPQInnerDataTemp, a, b);
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLPQInnerDataTempDc
 */
export class TLPQInnerDataTempDc extends Message<TLPQInnerDataTempDc> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.PQInnerData data2 = 1;
   */
  data2?: PQInnerData;

  constructor(data?: PartialMessage<TLPQInnerDataTempDc>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tech.monstrs.chats_system.core.v1alpha1.TLPQInnerDataTempDc";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data2", kind: "message", T: PQInnerData, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLPQInnerDataTempDc {
    return new TLPQInnerDataTempDc().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLPQInnerDataTempDc {
    return new TLPQInnerDataTempDc().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLPQInnerDataTempDc {
    return new TLPQInnerDataTempDc().fromJsonString(jsonString, options);
  }

  static equals(a: TLPQInnerDataTempDc | PlainMessage<TLPQInnerDataTempDc> | undefined, b: TLPQInnerDataTempDc | PlainMessage<TLPQInnerDataTempDc> | undefined): boolean {
    return proto3.util.equals(TLPQInnerDataTempDc, a, b);
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.ResPQ
 */
export class ResPQ extends Message<ResPQ> {
  /**
   * @generated from field: optional string predicate_name = 1;
   */
  predicateName?: string;

  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.TLConstructor constructor = 2;
   */
  constructor$?: TLConstructor;

  /**
   * @generated from field: optional bytes nonce = 3;
   */
  nonce?: Uint8Array;

  /**
   * @generated from field: optional bytes server_nonce = 4;
   */
  serverNonce?: Uint8Array;

  /**
   * @generated from field: optional string pq = 5;
   */
  pq?: string;

  /**
   * @generated from field: repeated int64 server_public_key_fingerprints = 6;
   */
  serverPublicKeyFingerprints: bigint[] = [];

  constructor(data?: PartialMessage<ResPQ>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tech.monstrs.chats_system.core.v1alpha1.ResPQ";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "predicate_name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "constructor", kind: "enum", T: proto3.getEnumType(TLConstructor), opt: true },
    { no: 3, name: "nonce", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 4, name: "server_nonce", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 5, name: "pq", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "server_public_key_fingerprints", kind: "scalar", T: 3 /* ScalarType.INT64 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResPQ {
    return new ResPQ().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResPQ {
    return new ResPQ().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResPQ {
    return new ResPQ().fromJsonString(jsonString, options);
  }

  static equals(a: ResPQ | PlainMessage<ResPQ> | undefined, b: ResPQ | PlainMessage<ResPQ> | undefined): boolean {
    return proto3.util.equals(ResPQ, a, b);
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLResPQ
 */
export class TLResPQ extends Message<TLResPQ> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.ResPQ data2 = 1;
   */
  data2?: ResPQ;

  constructor(data?: PartialMessage<TLResPQ>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tech.monstrs.chats_system.core.v1alpha1.TLResPQ";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data2", kind: "message", T: ResPQ, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLResPQ {
    return new TLResPQ().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLResPQ {
    return new TLResPQ().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLResPQ {
    return new TLResPQ().fromJsonString(jsonString, options);
  }

  static equals(a: TLResPQ | PlainMessage<TLResPQ> | undefined, b: TLResPQ | PlainMessage<TLResPQ> | undefined): boolean {
    return proto3.util.equals(TLResPQ, a, b);
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.ServerDHParams
 */
export class ServerDHParams extends Message<ServerDHParams> {
  /**
   * @generated from field: optional string predicate_name = 1;
   */
  predicateName?: string;

  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.TLConstructor constructor = 2;
   */
  constructor$?: TLConstructor;

  /**
   * @generated from field: optional bytes nonce = 3;
   */
  nonce?: Uint8Array;

  /**
   * @generated from field: optional bytes server_nonce = 4;
   */
  serverNonce?: Uint8Array;

  /**
   * @generated from field: optional bytes new_nonce_hash = 5;
   */
  newNonceHash?: Uint8Array;

  /**
   * @generated from field: optional string encrypted_answer = 6;
   */
  encryptedAnswer?: string;

  constructor(data?: PartialMessage<ServerDHParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tech.monstrs.chats_system.core.v1alpha1.ServerDHParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "predicate_name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "constructor", kind: "enum", T: proto3.getEnumType(TLConstructor), opt: true },
    { no: 3, name: "nonce", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 4, name: "server_nonce", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 5, name: "new_nonce_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 6, name: "encrypted_answer", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServerDHParams {
    return new ServerDHParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServerDHParams {
    return new ServerDHParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServerDHParams {
    return new ServerDHParams().fromJsonString(jsonString, options);
  }

  static equals(a: ServerDHParams | PlainMessage<ServerDHParams> | undefined, b: ServerDHParams | PlainMessage<ServerDHParams> | undefined): boolean {
    return proto3.util.equals(ServerDHParams, a, b);
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLServerDHParamsFail
 */
export class TLServerDHParamsFail extends Message<TLServerDHParamsFail> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.ServerDHParams data2 = 1;
   */
  data2?: ServerDHParams;

  constructor(data?: PartialMessage<TLServerDHParamsFail>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tech.monstrs.chats_system.core.v1alpha1.TLServerDHParamsFail";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data2", kind: "message", T: ServerDHParams, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLServerDHParamsFail {
    return new TLServerDHParamsFail().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLServerDHParamsFail {
    return new TLServerDHParamsFail().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLServerDHParamsFail {
    return new TLServerDHParamsFail().fromJsonString(jsonString, options);
  }

  static equals(a: TLServerDHParamsFail | PlainMessage<TLServerDHParamsFail> | undefined, b: TLServerDHParamsFail | PlainMessage<TLServerDHParamsFail> | undefined): boolean {
    return proto3.util.equals(TLServerDHParamsFail, a, b);
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLServerDHParamsOk
 */
export class TLServerDHParamsOk extends Message<TLServerDHParamsOk> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.ServerDHParams data2 = 1;
   */
  data2?: ServerDHParams;

  constructor(data?: PartialMessage<TLServerDHParamsOk>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tech.monstrs.chats_system.core.v1alpha1.TLServerDHParamsOk";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data2", kind: "message", T: ServerDHParams, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLServerDHParamsOk {
    return new TLServerDHParamsOk().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLServerDHParamsOk {
    return new TLServerDHParamsOk().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLServerDHParamsOk {
    return new TLServerDHParamsOk().fromJsonString(jsonString, options);
  }

  static equals(a: TLServerDHParamsOk | PlainMessage<TLServerDHParamsOk> | undefined, b: TLServerDHParamsOk | PlainMessage<TLServerDHParamsOk> | undefined): boolean {
    return proto3.util.equals(TLServerDHParamsOk, a, b);
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.ServerDHInnerData
 */
export class ServerDHInnerData extends Message<ServerDHInnerData> {
  /**
   * @generated from field: optional string predicate_name = 1;
   */
  predicateName?: string;

  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.TLConstructor constructor = 2;
   */
  constructor$?: TLConstructor;

  /**
   * @generated from field: optional bytes nonce = 3;
   */
  nonce?: Uint8Array;

  /**
   * @generated from field: optional bytes server_nonce = 4;
   */
  serverNonce?: Uint8Array;

  /**
   * @generated from field: optional int32 g = 5;
   */
  g?: number;

  /**
   * @generated from field: optional string dh_prime = 6;
   */
  dhPrime?: string;

  /**
   * @generated from field: optional string g_a = 7;
   */
  gA?: string;

  /**
   * @generated from field: optional int32 server_time = 8;
   */
  serverTime?: number;

  constructor(data?: PartialMessage<ServerDHInnerData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tech.monstrs.chats_system.core.v1alpha1.ServerDHInnerData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "predicate_name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "constructor", kind: "enum", T: proto3.getEnumType(TLConstructor), opt: true },
    { no: 3, name: "nonce", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 4, name: "server_nonce", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 5, name: "g", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 6, name: "dh_prime", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 7, name: "g_a", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 8, name: "server_time", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServerDHInnerData {
    return new ServerDHInnerData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServerDHInnerData {
    return new ServerDHInnerData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServerDHInnerData {
    return new ServerDHInnerData().fromJsonString(jsonString, options);
  }

  static equals(a: ServerDHInnerData | PlainMessage<ServerDHInnerData> | undefined, b: ServerDHInnerData | PlainMessage<ServerDHInnerData> | undefined): boolean {
    return proto3.util.equals(ServerDHInnerData, a, b);
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLServerDHInnerData
 */
export class TLServerDHInnerData extends Message<TLServerDHInnerData> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.ServerDHInnerData data2 = 1;
   */
  data2?: ServerDHInnerData;

  constructor(data?: PartialMessage<TLServerDHInnerData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tech.monstrs.chats_system.core.v1alpha1.TLServerDHInnerData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data2", kind: "message", T: ServerDHInnerData, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLServerDHInnerData {
    return new TLServerDHInnerData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLServerDHInnerData {
    return new TLServerDHInnerData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLServerDHInnerData {
    return new TLServerDHInnerData().fromJsonString(jsonString, options);
  }

  static equals(a: TLServerDHInnerData | PlainMessage<TLServerDHInnerData> | undefined, b: TLServerDHInnerData | PlainMessage<TLServerDHInnerData> | undefined): boolean {
    return proto3.util.equals(TLServerDHInnerData, a, b);
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.SetClientDHParamsAnswer
 */
export class SetClientDHParamsAnswer extends Message<SetClientDHParamsAnswer> {
  /**
   * @generated from field: optional string predicate_name = 1;
   */
  predicateName?: string;

  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.TLConstructor constructor = 2;
   */
  constructor$?: TLConstructor;

  /**
   * @generated from field: optional bytes nonce = 3;
   */
  nonce?: Uint8Array;

  /**
   * @generated from field: optional bytes server_nonce = 4;
   */
  serverNonce?: Uint8Array;

  /**
   * @generated from field: optional bytes new_nonce_hash1 = 5;
   */
  newNonceHash1?: Uint8Array;

  /**
   * @generated from field: optional bytes new_nonce_hash2 = 6;
   */
  newNonceHash2?: Uint8Array;

  /**
   * @generated from field: optional bytes new_nonce_hash3 = 7;
   */
  newNonceHash3?: Uint8Array;

  constructor(data?: PartialMessage<SetClientDHParamsAnswer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tech.monstrs.chats_system.core.v1alpha1.SetClientDHParamsAnswer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "predicate_name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "constructor", kind: "enum", T: proto3.getEnumType(TLConstructor), opt: true },
    { no: 3, name: "nonce", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 4, name: "server_nonce", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 5, name: "new_nonce_hash1", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 6, name: "new_nonce_hash2", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 7, name: "new_nonce_hash3", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetClientDHParamsAnswer {
    return new SetClientDHParamsAnswer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetClientDHParamsAnswer {
    return new SetClientDHParamsAnswer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetClientDHParamsAnswer {
    return new SetClientDHParamsAnswer().fromJsonString(jsonString, options);
  }

  static equals(a: SetClientDHParamsAnswer | PlainMessage<SetClientDHParamsAnswer> | undefined, b: SetClientDHParamsAnswer | PlainMessage<SetClientDHParamsAnswer> | undefined): boolean {
    return proto3.util.equals(SetClientDHParamsAnswer, a, b);
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLDhGenOk
 */
export class TLDhGenOk extends Message<TLDhGenOk> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.SetClientDHParamsAnswer data2 = 1;
   */
  data2?: SetClientDHParamsAnswer;

  constructor(data?: PartialMessage<TLDhGenOk>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tech.monstrs.chats_system.core.v1alpha1.TLDhGenOk";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data2", kind: "message", T: SetClientDHParamsAnswer, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLDhGenOk {
    return new TLDhGenOk().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLDhGenOk {
    return new TLDhGenOk().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLDhGenOk {
    return new TLDhGenOk().fromJsonString(jsonString, options);
  }

  static equals(a: TLDhGenOk | PlainMessage<TLDhGenOk> | undefined, b: TLDhGenOk | PlainMessage<TLDhGenOk> | undefined): boolean {
    return proto3.util.equals(TLDhGenOk, a, b);
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLDhGenRetry
 */
export class TLDhGenRetry extends Message<TLDhGenRetry> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.SetClientDHParamsAnswer data2 = 1;
   */
  data2?: SetClientDHParamsAnswer;

  constructor(data?: PartialMessage<TLDhGenRetry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tech.monstrs.chats_system.core.v1alpha1.TLDhGenRetry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data2", kind: "message", T: SetClientDHParamsAnswer, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLDhGenRetry {
    return new TLDhGenRetry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLDhGenRetry {
    return new TLDhGenRetry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLDhGenRetry {
    return new TLDhGenRetry().fromJsonString(jsonString, options);
  }

  static equals(a: TLDhGenRetry | PlainMessage<TLDhGenRetry> | undefined, b: TLDhGenRetry | PlainMessage<TLDhGenRetry> | undefined): boolean {
    return proto3.util.equals(TLDhGenRetry, a, b);
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLDhGenFail
 */
export class TLDhGenFail extends Message<TLDhGenFail> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.SetClientDHParamsAnswer data2 = 1;
   */
  data2?: SetClientDHParamsAnswer;

  constructor(data?: PartialMessage<TLDhGenFail>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "tech.monstrs.chats_system.core.v1alpha1.TLDhGenFail";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data2", kind: "message", T: SetClientDHParamsAnswer, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLDhGenFail {
    return new TLDhGenFail().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLDhGenFail {
    return new TLDhGenFail().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLDhGenFail {
    return new TLDhGenFail().fromJsonString(jsonString, options);
  }

  static equals(a: TLDhGenFail | PlainMessage<TLDhGenFail> | undefined, b: TLDhGenFail | PlainMessage<TLDhGenFail> | undefined): boolean {
    return proto3.util.equals(TLDhGenFail, a, b);
  }
}

