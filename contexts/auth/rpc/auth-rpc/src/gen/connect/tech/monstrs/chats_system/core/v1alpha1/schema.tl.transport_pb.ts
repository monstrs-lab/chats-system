// @generated by protoc-gen-es v1.4.1 with parameter "target=ts"
// @generated from file tech/monstrs/chats_system/core/v1alpha1/schema.tl.transport.proto (package tech.monstrs.chats_system.core.v1alpha1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions } from '@bufbuild/protobuf'
import type { FieldList }         from '@bufbuild/protobuf'
import type { JsonReadOptions }   from '@bufbuild/protobuf'
import type { JsonValue }         from '@bufbuild/protobuf'
import type { PartialMessage }    from '@bufbuild/protobuf'
import type { PlainMessage }      from '@bufbuild/protobuf'

import { Message }                from '@bufbuild/protobuf'
import { proto3 }                 from '@bufbuild/protobuf'

import { TLConstructor }          from './schema.tl.crc32_pb.js'

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.AccessPointRule
 */
export class AccessPointRule extends Message<AccessPointRule> {
  /**
   * @generated from field: optional string predicate_name = 1;
   */
  predicateName?: string

  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.TLConstructor constructor = 2;
   */
  constructor$?: TLConstructor

  /**
   * @generated from field: optional string phone_prefix_rules = 3;
   */
  phonePrefixRules?: string

  /**
   * @generated from field: optional int32 dc_id = 4;
   */
  dcId?: number

  /**
   * @generated from field: repeated tech.monstrs.chats_system.core.v1alpha1.IpPort ips = 5;
   */
  ips: IpPort[] = []

  constructor(data?: PartialMessage<AccessPointRule>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.AccessPointRule'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'predicate_name', kind: 'scalar', T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: 'constructor', kind: 'enum', T: proto3.getEnumType(TLConstructor), opt: true },
    { no: 3, name: 'phone_prefix_rules', kind: 'scalar', T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: 'dc_id', kind: 'scalar', T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 5, name: 'ips', kind: 'message', T: IpPort, repeated: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessPointRule {
    return new AccessPointRule().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessPointRule {
    return new AccessPointRule().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessPointRule {
    return new AccessPointRule().fromJsonString(jsonString, options)
  }

  static equals(
    a: AccessPointRule | PlainMessage<AccessPointRule> | undefined,
    b: AccessPointRule | PlainMessage<AccessPointRule> | undefined
  ): boolean {
    return proto3.util.equals(AccessPointRule, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLAccessPointRule
 */
export class TLAccessPointRule extends Message<TLAccessPointRule> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.AccessPointRule data2 = 1;
   */
  data2?: AccessPointRule

  constructor(data?: PartialMessage<TLAccessPointRule>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.TLAccessPointRule'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'data2', kind: 'message', T: AccessPointRule, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLAccessPointRule {
    return new TLAccessPointRule().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLAccessPointRule {
    return new TLAccessPointRule().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLAccessPointRule {
    return new TLAccessPointRule().fromJsonString(jsonString, options)
  }

  static equals(
    a: TLAccessPointRule | PlainMessage<TLAccessPointRule> | undefined,
    b: TLAccessPointRule | PlainMessage<TLAccessPointRule> | undefined
  ): boolean {
    return proto3.util.equals(TLAccessPointRule, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.BadMsgNotification
 */
export class BadMsgNotification extends Message<BadMsgNotification> {
  /**
   * @generated from field: optional string predicate_name = 1;
   */
  predicateName?: string

  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.TLConstructor constructor = 2;
   */
  constructor$?: TLConstructor

  /**
   * @generated from field: optional int64 bad_msg_id = 3;
   */
  badMsgId?: bigint

  /**
   * @generated from field: optional int32 bad_msg_seqno = 4;
   */
  badMsgSeqno?: number

  /**
   * @generated from field: optional int32 error_code = 5;
   */
  errorCode?: number

  /**
   * @generated from field: optional int64 new_server_salt = 6;
   */
  newServerSalt?: bigint

  constructor(data?: PartialMessage<BadMsgNotification>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.BadMsgNotification'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'predicate_name', kind: 'scalar', T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: 'constructor', kind: 'enum', T: proto3.getEnumType(TLConstructor), opt: true },
    { no: 3, name: 'bad_msg_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 4, name: 'bad_msg_seqno', kind: 'scalar', T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 5, name: 'error_code', kind: 'scalar', T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 6, name: 'new_server_salt', kind: 'scalar', T: 3 /* ScalarType.INT64 */, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BadMsgNotification {
    return new BadMsgNotification().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BadMsgNotification {
    return new BadMsgNotification().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): BadMsgNotification {
    return new BadMsgNotification().fromJsonString(jsonString, options)
  }

  static equals(
    a: BadMsgNotification | PlainMessage<BadMsgNotification> | undefined,
    b: BadMsgNotification | PlainMessage<BadMsgNotification> | undefined
  ): boolean {
    return proto3.util.equals(BadMsgNotification, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLBadMsgNotification
 */
export class TLBadMsgNotification extends Message<TLBadMsgNotification> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.BadMsgNotification data2 = 1;
   */
  data2?: BadMsgNotification

  constructor(data?: PartialMessage<TLBadMsgNotification>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.TLBadMsgNotification'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'data2', kind: 'message', T: BadMsgNotification, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLBadMsgNotification {
    return new TLBadMsgNotification().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLBadMsgNotification {
    return new TLBadMsgNotification().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): TLBadMsgNotification {
    return new TLBadMsgNotification().fromJsonString(jsonString, options)
  }

  static equals(
    a: TLBadMsgNotification | PlainMessage<TLBadMsgNotification> | undefined,
    b: TLBadMsgNotification | PlainMessage<TLBadMsgNotification> | undefined
  ): boolean {
    return proto3.util.equals(TLBadMsgNotification, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLBadServerSalt
 */
export class TLBadServerSalt extends Message<TLBadServerSalt> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.BadMsgNotification data2 = 1;
   */
  data2?: BadMsgNotification

  constructor(data?: PartialMessage<TLBadServerSalt>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.TLBadServerSalt'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'data2', kind: 'message', T: BadMsgNotification, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLBadServerSalt {
    return new TLBadServerSalt().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLBadServerSalt {
    return new TLBadServerSalt().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLBadServerSalt {
    return new TLBadServerSalt().fromJsonString(jsonString, options)
  }

  static equals(
    a: TLBadServerSalt | PlainMessage<TLBadServerSalt> | undefined,
    b: TLBadServerSalt | PlainMessage<TLBadServerSalt> | undefined
  ): boolean {
    return proto3.util.equals(TLBadServerSalt, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.DestroySessionRes
 */
export class DestroySessionRes extends Message<DestroySessionRes> {
  /**
   * @generated from field: optional string predicate_name = 1;
   */
  predicateName?: string

  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.TLConstructor constructor = 2;
   */
  constructor$?: TLConstructor

  /**
   * @generated from field: optional int64 session_id = 3;
   */
  sessionId?: bigint

  constructor(data?: PartialMessage<DestroySessionRes>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.DestroySessionRes'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'predicate_name', kind: 'scalar', T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: 'constructor', kind: 'enum', T: proto3.getEnumType(TLConstructor), opt: true },
    { no: 3, name: 'session_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DestroySessionRes {
    return new DestroySessionRes().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DestroySessionRes {
    return new DestroySessionRes().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DestroySessionRes {
    return new DestroySessionRes().fromJsonString(jsonString, options)
  }

  static equals(
    a: DestroySessionRes | PlainMessage<DestroySessionRes> | undefined,
    b: DestroySessionRes | PlainMessage<DestroySessionRes> | undefined
  ): boolean {
    return proto3.util.equals(DestroySessionRes, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLDestroySessionOk
 */
export class TLDestroySessionOk extends Message<TLDestroySessionOk> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.DestroySessionRes data2 = 1;
   */
  data2?: DestroySessionRes

  constructor(data?: PartialMessage<TLDestroySessionOk>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.TLDestroySessionOk'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'data2', kind: 'message', T: DestroySessionRes, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLDestroySessionOk {
    return new TLDestroySessionOk().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLDestroySessionOk {
    return new TLDestroySessionOk().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): TLDestroySessionOk {
    return new TLDestroySessionOk().fromJsonString(jsonString, options)
  }

  static equals(
    a: TLDestroySessionOk | PlainMessage<TLDestroySessionOk> | undefined,
    b: TLDestroySessionOk | PlainMessage<TLDestroySessionOk> | undefined
  ): boolean {
    return proto3.util.equals(TLDestroySessionOk, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLDestroySessionNone
 */
export class TLDestroySessionNone extends Message<TLDestroySessionNone> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.DestroySessionRes data2 = 1;
   */
  data2?: DestroySessionRes

  constructor(data?: PartialMessage<TLDestroySessionNone>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.TLDestroySessionNone'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'data2', kind: 'message', T: DestroySessionRes, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLDestroySessionNone {
    return new TLDestroySessionNone().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLDestroySessionNone {
    return new TLDestroySessionNone().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): TLDestroySessionNone {
    return new TLDestroySessionNone().fromJsonString(jsonString, options)
  }

  static equals(
    a: TLDestroySessionNone | PlainMessage<TLDestroySessionNone> | undefined,
    b: TLDestroySessionNone | PlainMessage<TLDestroySessionNone> | undefined
  ): boolean {
    return proto3.util.equals(TLDestroySessionNone, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.FutureSalt
 */
export class FutureSalt extends Message<FutureSalt> {
  /**
   * @generated from field: optional string predicate_name = 1;
   */
  predicateName?: string

  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.TLConstructor constructor = 2;
   */
  constructor$?: TLConstructor

  /**
   * @generated from field: optional int32 valid_since = 3;
   */
  validSince?: number

  /**
   * @generated from field: optional int32 valid_until = 4;
   */
  validUntil?: number

  /**
   * @generated from field: optional int64 salt = 5;
   */
  salt?: bigint

  constructor(data?: PartialMessage<FutureSalt>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.FutureSalt'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'predicate_name', kind: 'scalar', T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: 'constructor', kind: 'enum', T: proto3.getEnumType(TLConstructor), opt: true },
    { no: 3, name: 'valid_since', kind: 'scalar', T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 4, name: 'valid_until', kind: 'scalar', T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 5, name: 'salt', kind: 'scalar', T: 3 /* ScalarType.INT64 */, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FutureSalt {
    return new FutureSalt().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FutureSalt {
    return new FutureSalt().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FutureSalt {
    return new FutureSalt().fromJsonString(jsonString, options)
  }

  static equals(
    a: FutureSalt | PlainMessage<FutureSalt> | undefined,
    b: FutureSalt | PlainMessage<FutureSalt> | undefined
  ): boolean {
    return proto3.util.equals(FutureSalt, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLFutureSalt
 */
export class TLFutureSalt extends Message<TLFutureSalt> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.FutureSalt data2 = 1;
   */
  data2?: FutureSalt

  constructor(data?: PartialMessage<TLFutureSalt>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.TLFutureSalt'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'data2', kind: 'message', T: FutureSalt, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLFutureSalt {
    return new TLFutureSalt().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLFutureSalt {
    return new TLFutureSalt().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLFutureSalt {
    return new TLFutureSalt().fromJsonString(jsonString, options)
  }

  static equals(
    a: TLFutureSalt | PlainMessage<TLFutureSalt> | undefined,
    b: TLFutureSalt | PlainMessage<TLFutureSalt> | undefined
  ): boolean {
    return proto3.util.equals(TLFutureSalt, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.FutureSalts
 */
export class FutureSalts extends Message<FutureSalts> {
  /**
   * @generated from field: optional string predicate_name = 1;
   */
  predicateName?: string

  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.TLConstructor constructor = 2;
   */
  constructor$?: TLConstructor

  /**
   * @generated from field: optional int64 req_msg_id = 3;
   */
  reqMsgId?: bigint

  /**
   * @generated from field: optional int32 now = 4;
   */
  now?: number

  /**
   * @generated from field: repeated tech.monstrs.chats_system.core.v1alpha1.TLFutureSalt salts = 5;
   */
  salts: TLFutureSalt[] = []

  constructor(data?: PartialMessage<FutureSalts>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.FutureSalts'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'predicate_name', kind: 'scalar', T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: 'constructor', kind: 'enum', T: proto3.getEnumType(TLConstructor), opt: true },
    { no: 3, name: 'req_msg_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 4, name: 'now', kind: 'scalar', T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 5, name: 'salts', kind: 'message', T: TLFutureSalt, repeated: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FutureSalts {
    return new FutureSalts().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FutureSalts {
    return new FutureSalts().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FutureSalts {
    return new FutureSalts().fromJsonString(jsonString, options)
  }

  static equals(
    a: FutureSalts | PlainMessage<FutureSalts> | undefined,
    b: FutureSalts | PlainMessage<FutureSalts> | undefined
  ): boolean {
    return proto3.util.equals(FutureSalts, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLFutureSalts
 */
export class TLFutureSalts extends Message<TLFutureSalts> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.FutureSalts data2 = 1;
   */
  data2?: FutureSalts

  constructor(data?: PartialMessage<TLFutureSalts>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.TLFutureSalts'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'data2', kind: 'message', T: FutureSalts, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLFutureSalts {
    return new TLFutureSalts().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLFutureSalts {
    return new TLFutureSalts().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLFutureSalts {
    return new TLFutureSalts().fromJsonString(jsonString, options)
  }

  static equals(
    a: TLFutureSalts | PlainMessage<TLFutureSalts> | undefined,
    b: TLFutureSalts | PlainMessage<TLFutureSalts> | undefined
  ): boolean {
    return proto3.util.equals(TLFutureSalts, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.HttpWait
 */
export class HttpWait extends Message<HttpWait> {
  /**
   * @generated from field: optional string predicate_name = 1;
   */
  predicateName?: string

  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.TLConstructor constructor = 2;
   */
  constructor$?: TLConstructor

  /**
   * @generated from field: optional int32 max_delay = 3;
   */
  maxDelay?: number

  /**
   * @generated from field: optional int32 wait_after = 4;
   */
  waitAfter?: number

  /**
   * @generated from field: optional int32 max_wait = 5;
   */
  maxWait?: number

  constructor(data?: PartialMessage<HttpWait>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.HttpWait'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'predicate_name', kind: 'scalar', T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: 'constructor', kind: 'enum', T: proto3.getEnumType(TLConstructor), opt: true },
    { no: 3, name: 'max_delay', kind: 'scalar', T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 4, name: 'wait_after', kind: 'scalar', T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 5, name: 'max_wait', kind: 'scalar', T: 5 /* ScalarType.INT32 */, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HttpWait {
    return new HttpWait().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HttpWait {
    return new HttpWait().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HttpWait {
    return new HttpWait().fromJsonString(jsonString, options)
  }

  static equals(
    a: HttpWait | PlainMessage<HttpWait> | undefined,
    b: HttpWait | PlainMessage<HttpWait> | undefined
  ): boolean {
    return proto3.util.equals(HttpWait, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLHttpWait
 */
export class TLHttpWait extends Message<TLHttpWait> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.HttpWait data2 = 1;
   */
  data2?: HttpWait

  constructor(data?: PartialMessage<TLHttpWait>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.TLHttpWait'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'data2', kind: 'message', T: HttpWait, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLHttpWait {
    return new TLHttpWait().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLHttpWait {
    return new TLHttpWait().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLHttpWait {
    return new TLHttpWait().fromJsonString(jsonString, options)
  }

  static equals(
    a: TLHttpWait | PlainMessage<TLHttpWait> | undefined,
    b: TLHttpWait | PlainMessage<TLHttpWait> | undefined
  ): boolean {
    return proto3.util.equals(TLHttpWait, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.IpPort
 */
export class IpPort extends Message<IpPort> {
  /**
   * @generated from field: optional string predicate_name = 1;
   */
  predicateName?: string

  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.TLConstructor constructor = 2;
   */
  constructor$?: TLConstructor

  /**
   * @generated from field: optional int32 ipv4 = 3;
   */
  ipv4?: number

  /**
   * @generated from field: optional int32 port = 4;
   */
  port?: number

  /**
   * @generated from field: optional bytes secret = 5;
   */
  secret?: Uint8Array

  constructor(data?: PartialMessage<IpPort>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.IpPort'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'predicate_name', kind: 'scalar', T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: 'constructor', kind: 'enum', T: proto3.getEnumType(TLConstructor), opt: true },
    { no: 3, name: 'ipv4', kind: 'scalar', T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 4, name: 'port', kind: 'scalar', T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 5, name: 'secret', kind: 'scalar', T: 12 /* ScalarType.BYTES */, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IpPort {
    return new IpPort().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IpPort {
    return new IpPort().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IpPort {
    return new IpPort().fromJsonString(jsonString, options)
  }

  static equals(
    a: IpPort | PlainMessage<IpPort> | undefined,
    b: IpPort | PlainMessage<IpPort> | undefined
  ): boolean {
    return proto3.util.equals(IpPort, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLIpPort
 */
export class TLIpPort extends Message<TLIpPort> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.IpPort data2 = 1;
   */
  data2?: IpPort

  constructor(data?: PartialMessage<TLIpPort>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.TLIpPort'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'data2', kind: 'message', T: IpPort, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLIpPort {
    return new TLIpPort().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLIpPort {
    return new TLIpPort().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLIpPort {
    return new TLIpPort().fromJsonString(jsonString, options)
  }

  static equals(
    a: TLIpPort | PlainMessage<TLIpPort> | undefined,
    b: TLIpPort | PlainMessage<TLIpPort> | undefined
  ): boolean {
    return proto3.util.equals(TLIpPort, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLIpPortSecret
 */
export class TLIpPortSecret extends Message<TLIpPortSecret> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.IpPort data2 = 1;
   */
  data2?: IpPort

  constructor(data?: PartialMessage<TLIpPortSecret>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.TLIpPortSecret'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'data2', kind: 'message', T: IpPort, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLIpPortSecret {
    return new TLIpPortSecret().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLIpPortSecret {
    return new TLIpPortSecret().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLIpPortSecret {
    return new TLIpPortSecret().fromJsonString(jsonString, options)
  }

  static equals(
    a: TLIpPortSecret | PlainMessage<TLIpPortSecret> | undefined,
    b: TLIpPortSecret | PlainMessage<TLIpPortSecret> | undefined
  ): boolean {
    return proto3.util.equals(TLIpPortSecret, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.MsgDetailedInfo
 */
export class MsgDetailedInfo extends Message<MsgDetailedInfo> {
  /**
   * @generated from field: optional string predicate_name = 1;
   */
  predicateName?: string

  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.TLConstructor constructor = 2;
   */
  constructor$?: TLConstructor

  /**
   * @generated from field: optional int64 msg_id = 3;
   */
  msgId?: bigint

  /**
   * @generated from field: optional int64 answer_msg_id = 4;
   */
  answerMsgId?: bigint

  /**
   * @generated from field: optional int32 bytes = 5;
   */
  bytes?: number

  /**
   * @generated from field: optional int32 status = 6;
   */
  status?: number

  constructor(data?: PartialMessage<MsgDetailedInfo>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.MsgDetailedInfo'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'predicate_name', kind: 'scalar', T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: 'constructor', kind: 'enum', T: proto3.getEnumType(TLConstructor), opt: true },
    { no: 3, name: 'msg_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 4, name: 'answer_msg_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 5, name: 'bytes', kind: 'scalar', T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 6, name: 'status', kind: 'scalar', T: 5 /* ScalarType.INT32 */, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgDetailedInfo {
    return new MsgDetailedInfo().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgDetailedInfo {
    return new MsgDetailedInfo().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgDetailedInfo {
    return new MsgDetailedInfo().fromJsonString(jsonString, options)
  }

  static equals(
    a: MsgDetailedInfo | PlainMessage<MsgDetailedInfo> | undefined,
    b: MsgDetailedInfo | PlainMessage<MsgDetailedInfo> | undefined
  ): boolean {
    return proto3.util.equals(MsgDetailedInfo, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLMsgDetailedInfo
 */
export class TLMsgDetailedInfo extends Message<TLMsgDetailedInfo> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.MsgDetailedInfo data2 = 1;
   */
  data2?: MsgDetailedInfo

  constructor(data?: PartialMessage<TLMsgDetailedInfo>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.TLMsgDetailedInfo'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'data2', kind: 'message', T: MsgDetailedInfo, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLMsgDetailedInfo {
    return new TLMsgDetailedInfo().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLMsgDetailedInfo {
    return new TLMsgDetailedInfo().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLMsgDetailedInfo {
    return new TLMsgDetailedInfo().fromJsonString(jsonString, options)
  }

  static equals(
    a: TLMsgDetailedInfo | PlainMessage<TLMsgDetailedInfo> | undefined,
    b: TLMsgDetailedInfo | PlainMessage<TLMsgDetailedInfo> | undefined
  ): boolean {
    return proto3.util.equals(TLMsgDetailedInfo, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLMsgNewDetailedInfo
 */
export class TLMsgNewDetailedInfo extends Message<TLMsgNewDetailedInfo> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.MsgDetailedInfo data2 = 1;
   */
  data2?: MsgDetailedInfo

  constructor(data?: PartialMessage<TLMsgNewDetailedInfo>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.TLMsgNewDetailedInfo'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'data2', kind: 'message', T: MsgDetailedInfo, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLMsgNewDetailedInfo {
    return new TLMsgNewDetailedInfo().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLMsgNewDetailedInfo {
    return new TLMsgNewDetailedInfo().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): TLMsgNewDetailedInfo {
    return new TLMsgNewDetailedInfo().fromJsonString(jsonString, options)
  }

  static equals(
    a: TLMsgNewDetailedInfo | PlainMessage<TLMsgNewDetailedInfo> | undefined,
    b: TLMsgNewDetailedInfo | PlainMessage<TLMsgNewDetailedInfo> | undefined
  ): boolean {
    return proto3.util.equals(TLMsgNewDetailedInfo, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.MsgResendReq
 */
export class MsgResendReq extends Message<MsgResendReq> {
  /**
   * @generated from field: optional string predicate_name = 1;
   */
  predicateName?: string

  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.TLConstructor constructor = 2;
   */
  constructor$?: TLConstructor

  /**
   * @generated from field: repeated int64 msg_ids = 3;
   */
  msgIds: bigint[] = []

  constructor(data?: PartialMessage<MsgResendReq>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.MsgResendReq'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'predicate_name', kind: 'scalar', T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: 'constructor', kind: 'enum', T: proto3.getEnumType(TLConstructor), opt: true },
    { no: 3, name: 'msg_ids', kind: 'scalar', T: 3 /* ScalarType.INT64 */, repeated: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgResendReq {
    return new MsgResendReq().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgResendReq {
    return new MsgResendReq().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgResendReq {
    return new MsgResendReq().fromJsonString(jsonString, options)
  }

  static equals(
    a: MsgResendReq | PlainMessage<MsgResendReq> | undefined,
    b: MsgResendReq | PlainMessage<MsgResendReq> | undefined
  ): boolean {
    return proto3.util.equals(MsgResendReq, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLMsgResendReq
 */
export class TLMsgResendReq extends Message<TLMsgResendReq> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.MsgResendReq data2 = 1;
   */
  data2?: MsgResendReq

  constructor(data?: PartialMessage<TLMsgResendReq>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.TLMsgResendReq'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'data2', kind: 'message', T: MsgResendReq, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLMsgResendReq {
    return new TLMsgResendReq().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLMsgResendReq {
    return new TLMsgResendReq().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLMsgResendReq {
    return new TLMsgResendReq().fromJsonString(jsonString, options)
  }

  static equals(
    a: TLMsgResendReq | PlainMessage<TLMsgResendReq> | undefined,
    b: TLMsgResendReq | PlainMessage<TLMsgResendReq> | undefined
  ): boolean {
    return proto3.util.equals(TLMsgResendReq, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.MsgsAck
 */
export class MsgsAck extends Message<MsgsAck> {
  /**
   * @generated from field: optional string predicate_name = 1;
   */
  predicateName?: string

  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.TLConstructor constructor = 2;
   */
  constructor$?: TLConstructor

  /**
   * @generated from field: repeated int64 msg_ids = 3;
   */
  msgIds: bigint[] = []

  constructor(data?: PartialMessage<MsgsAck>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.MsgsAck'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'predicate_name', kind: 'scalar', T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: 'constructor', kind: 'enum', T: proto3.getEnumType(TLConstructor), opt: true },
    { no: 3, name: 'msg_ids', kind: 'scalar', T: 3 /* ScalarType.INT64 */, repeated: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgsAck {
    return new MsgsAck().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgsAck {
    return new MsgsAck().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgsAck {
    return new MsgsAck().fromJsonString(jsonString, options)
  }

  static equals(
    a: MsgsAck | PlainMessage<MsgsAck> | undefined,
    b: MsgsAck | PlainMessage<MsgsAck> | undefined
  ): boolean {
    return proto3.util.equals(MsgsAck, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLMsgsAck
 */
export class TLMsgsAck extends Message<TLMsgsAck> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.MsgsAck data2 = 1;
   */
  data2?: MsgsAck

  constructor(data?: PartialMessage<TLMsgsAck>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.TLMsgsAck'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'data2', kind: 'message', T: MsgsAck, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLMsgsAck {
    return new TLMsgsAck().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLMsgsAck {
    return new TLMsgsAck().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLMsgsAck {
    return new TLMsgsAck().fromJsonString(jsonString, options)
  }

  static equals(
    a: TLMsgsAck | PlainMessage<TLMsgsAck> | undefined,
    b: TLMsgsAck | PlainMessage<TLMsgsAck> | undefined
  ): boolean {
    return proto3.util.equals(TLMsgsAck, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.MsgsAllInfo
 */
export class MsgsAllInfo extends Message<MsgsAllInfo> {
  /**
   * @generated from field: optional string predicate_name = 1;
   */
  predicateName?: string

  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.TLConstructor constructor = 2;
   */
  constructor$?: TLConstructor

  /**
   * @generated from field: repeated int64 msg_ids = 3;
   */
  msgIds: bigint[] = []

  /**
   * @generated from field: optional string info = 4;
   */
  info?: string

  constructor(data?: PartialMessage<MsgsAllInfo>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.MsgsAllInfo'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'predicate_name', kind: 'scalar', T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: 'constructor', kind: 'enum', T: proto3.getEnumType(TLConstructor), opt: true },
    { no: 3, name: 'msg_ids', kind: 'scalar', T: 3 /* ScalarType.INT64 */, repeated: true },
    { no: 4, name: 'info', kind: 'scalar', T: 9 /* ScalarType.STRING */, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgsAllInfo {
    return new MsgsAllInfo().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgsAllInfo {
    return new MsgsAllInfo().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgsAllInfo {
    return new MsgsAllInfo().fromJsonString(jsonString, options)
  }

  static equals(
    a: MsgsAllInfo | PlainMessage<MsgsAllInfo> | undefined,
    b: MsgsAllInfo | PlainMessage<MsgsAllInfo> | undefined
  ): boolean {
    return proto3.util.equals(MsgsAllInfo, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLMsgsAllInfo
 */
export class TLMsgsAllInfo extends Message<TLMsgsAllInfo> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.MsgsAllInfo data2 = 1;
   */
  data2?: MsgsAllInfo

  constructor(data?: PartialMessage<TLMsgsAllInfo>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.TLMsgsAllInfo'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'data2', kind: 'message', T: MsgsAllInfo, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLMsgsAllInfo {
    return new TLMsgsAllInfo().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLMsgsAllInfo {
    return new TLMsgsAllInfo().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLMsgsAllInfo {
    return new TLMsgsAllInfo().fromJsonString(jsonString, options)
  }

  static equals(
    a: TLMsgsAllInfo | PlainMessage<TLMsgsAllInfo> | undefined,
    b: TLMsgsAllInfo | PlainMessage<TLMsgsAllInfo> | undefined
  ): boolean {
    return proto3.util.equals(TLMsgsAllInfo, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.MsgsStateInfo
 */
export class MsgsStateInfo extends Message<MsgsStateInfo> {
  /**
   * @generated from field: optional string predicate_name = 1;
   */
  predicateName?: string

  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.TLConstructor constructor = 2;
   */
  constructor$?: TLConstructor

  /**
   * @generated from field: optional int64 req_msg_id = 3;
   */
  reqMsgId?: bigint

  /**
   * @generated from field: optional string info = 4;
   */
  info?: string

  constructor(data?: PartialMessage<MsgsStateInfo>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.MsgsStateInfo'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'predicate_name', kind: 'scalar', T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: 'constructor', kind: 'enum', T: proto3.getEnumType(TLConstructor), opt: true },
    { no: 3, name: 'req_msg_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 4, name: 'info', kind: 'scalar', T: 9 /* ScalarType.STRING */, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgsStateInfo {
    return new MsgsStateInfo().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgsStateInfo {
    return new MsgsStateInfo().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgsStateInfo {
    return new MsgsStateInfo().fromJsonString(jsonString, options)
  }

  static equals(
    a: MsgsStateInfo | PlainMessage<MsgsStateInfo> | undefined,
    b: MsgsStateInfo | PlainMessage<MsgsStateInfo> | undefined
  ): boolean {
    return proto3.util.equals(MsgsStateInfo, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLMsgsStateInfo
 */
export class TLMsgsStateInfo extends Message<TLMsgsStateInfo> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.MsgsStateInfo data2 = 1;
   */
  data2?: MsgsStateInfo

  constructor(data?: PartialMessage<TLMsgsStateInfo>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.TLMsgsStateInfo'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'data2', kind: 'message', T: MsgsStateInfo, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLMsgsStateInfo {
    return new TLMsgsStateInfo().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLMsgsStateInfo {
    return new TLMsgsStateInfo().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLMsgsStateInfo {
    return new TLMsgsStateInfo().fromJsonString(jsonString, options)
  }

  static equals(
    a: TLMsgsStateInfo | PlainMessage<TLMsgsStateInfo> | undefined,
    b: TLMsgsStateInfo | PlainMessage<TLMsgsStateInfo> | undefined
  ): boolean {
    return proto3.util.equals(TLMsgsStateInfo, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.MsgsStateReq
 */
export class MsgsStateReq extends Message<MsgsStateReq> {
  /**
   * @generated from field: optional string predicate_name = 1;
   */
  predicateName?: string

  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.TLConstructor constructor = 2;
   */
  constructor$?: TLConstructor

  /**
   * @generated from field: repeated int64 msg_ids = 3;
   */
  msgIds: bigint[] = []

  constructor(data?: PartialMessage<MsgsStateReq>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.MsgsStateReq'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'predicate_name', kind: 'scalar', T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: 'constructor', kind: 'enum', T: proto3.getEnumType(TLConstructor), opt: true },
    { no: 3, name: 'msg_ids', kind: 'scalar', T: 3 /* ScalarType.INT64 */, repeated: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgsStateReq {
    return new MsgsStateReq().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgsStateReq {
    return new MsgsStateReq().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgsStateReq {
    return new MsgsStateReq().fromJsonString(jsonString, options)
  }

  static equals(
    a: MsgsStateReq | PlainMessage<MsgsStateReq> | undefined,
    b: MsgsStateReq | PlainMessage<MsgsStateReq> | undefined
  ): boolean {
    return proto3.util.equals(MsgsStateReq, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLMsgsStateReq
 */
export class TLMsgsStateReq extends Message<TLMsgsStateReq> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.MsgsStateReq data2 = 1;
   */
  data2?: MsgsStateReq

  constructor(data?: PartialMessage<TLMsgsStateReq>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.TLMsgsStateReq'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'data2', kind: 'message', T: MsgsStateReq, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLMsgsStateReq {
    return new TLMsgsStateReq().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLMsgsStateReq {
    return new TLMsgsStateReq().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLMsgsStateReq {
    return new TLMsgsStateReq().fromJsonString(jsonString, options)
  }

  static equals(
    a: TLMsgsStateReq | PlainMessage<TLMsgsStateReq> | undefined,
    b: TLMsgsStateReq | PlainMessage<TLMsgsStateReq> | undefined
  ): boolean {
    return proto3.util.equals(TLMsgsStateReq, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.NewSession
 */
export class NewSession extends Message<NewSession> {
  /**
   * @generated from field: optional string predicate_name = 1;
   */
  predicateName?: string

  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.TLConstructor constructor = 2;
   */
  constructor$?: TLConstructor

  /**
   * @generated from field: optional int64 first_msg_id = 3;
   */
  firstMsgId?: bigint

  /**
   * @generated from field: optional int64 unique_id = 4;
   */
  uniqueId?: bigint

  /**
   * @generated from field: optional int64 server_salt = 5;
   */
  serverSalt?: bigint

  constructor(data?: PartialMessage<NewSession>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.NewSession'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'predicate_name', kind: 'scalar', T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: 'constructor', kind: 'enum', T: proto3.getEnumType(TLConstructor), opt: true },
    { no: 3, name: 'first_msg_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 4, name: 'unique_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 5, name: 'server_salt', kind: 'scalar', T: 3 /* ScalarType.INT64 */, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NewSession {
    return new NewSession().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NewSession {
    return new NewSession().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NewSession {
    return new NewSession().fromJsonString(jsonString, options)
  }

  static equals(
    a: NewSession | PlainMessage<NewSession> | undefined,
    b: NewSession | PlainMessage<NewSession> | undefined
  ): boolean {
    return proto3.util.equals(NewSession, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLNewSessionCreated
 */
export class TLNewSessionCreated extends Message<TLNewSessionCreated> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.NewSession data2 = 1;
   */
  data2?: NewSession

  constructor(data?: PartialMessage<TLNewSessionCreated>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.TLNewSessionCreated'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'data2', kind: 'message', T: NewSession, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLNewSessionCreated {
    return new TLNewSessionCreated().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLNewSessionCreated {
    return new TLNewSessionCreated().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): TLNewSessionCreated {
    return new TLNewSessionCreated().fromJsonString(jsonString, options)
  }

  static equals(
    a: TLNewSessionCreated | PlainMessage<TLNewSessionCreated> | undefined,
    b: TLNewSessionCreated | PlainMessage<TLNewSessionCreated> | undefined
  ): boolean {
    return proto3.util.equals(TLNewSessionCreated, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.Pong
 */
export class Pong extends Message<Pong> {
  /**
   * @generated from field: optional string predicate_name = 1;
   */
  predicateName?: string

  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.TLConstructor constructor = 2;
   */
  constructor$?: TLConstructor

  /**
   * @generated from field: optional int64 msg_id = 3;
   */
  msgId?: bigint

  /**
   * @generated from field: optional int64 ping_id = 4;
   */
  pingId?: bigint

  constructor(data?: PartialMessage<Pong>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.Pong'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'predicate_name', kind: 'scalar', T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: 'constructor', kind: 'enum', T: proto3.getEnumType(TLConstructor), opt: true },
    { no: 3, name: 'msg_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 4, name: 'ping_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Pong {
    return new Pong().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Pong {
    return new Pong().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Pong {
    return new Pong().fromJsonString(jsonString, options)
  }

  static equals(
    a: Pong | PlainMessage<Pong> | undefined,
    b: Pong | PlainMessage<Pong> | undefined
  ): boolean {
    return proto3.util.equals(Pong, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLPong
 */
export class TLPong extends Message<TLPong> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.Pong data2 = 1;
   */
  data2?: Pong

  constructor(data?: PartialMessage<TLPong>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.TLPong'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'data2', kind: 'message', T: Pong, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLPong {
    return new TLPong().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLPong {
    return new TLPong().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLPong {
    return new TLPong().fromJsonString(jsonString, options)
  }

  static equals(
    a: TLPong | PlainMessage<TLPong> | undefined,
    b: TLPong | PlainMessage<TLPong> | undefined
  ): boolean {
    return proto3.util.equals(TLPong, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.RpcDropAnswer
 */
export class RpcDropAnswer extends Message<RpcDropAnswer> {
  /**
   * @generated from field: optional string predicate_name = 1;
   */
  predicateName?: string

  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.TLConstructor constructor = 2;
   */
  constructor$?: TLConstructor

  /**
   * @generated from field: optional int64 msg_id = 3;
   */
  msgId?: bigint

  /**
   * @generated from field: optional int32 seq_no = 4;
   */
  seqNo?: number

  /**
   * @generated from field: optional int32 bytes = 5;
   */
  bytes?: number

  constructor(data?: PartialMessage<RpcDropAnswer>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.RpcDropAnswer'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'predicate_name', kind: 'scalar', T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: 'constructor', kind: 'enum', T: proto3.getEnumType(TLConstructor), opt: true },
    { no: 3, name: 'msg_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 4, name: 'seq_no', kind: 'scalar', T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 5, name: 'bytes', kind: 'scalar', T: 5 /* ScalarType.INT32 */, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RpcDropAnswer {
    return new RpcDropAnswer().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RpcDropAnswer {
    return new RpcDropAnswer().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RpcDropAnswer {
    return new RpcDropAnswer().fromJsonString(jsonString, options)
  }

  static equals(
    a: RpcDropAnswer | PlainMessage<RpcDropAnswer> | undefined,
    b: RpcDropAnswer | PlainMessage<RpcDropAnswer> | undefined
  ): boolean {
    return proto3.util.equals(RpcDropAnswer, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLRpcAnswerUnknown
 */
export class TLRpcAnswerUnknown extends Message<TLRpcAnswerUnknown> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.RpcDropAnswer data2 = 1;
   */
  data2?: RpcDropAnswer

  constructor(data?: PartialMessage<TLRpcAnswerUnknown>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.TLRpcAnswerUnknown'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'data2', kind: 'message', T: RpcDropAnswer, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLRpcAnswerUnknown {
    return new TLRpcAnswerUnknown().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLRpcAnswerUnknown {
    return new TLRpcAnswerUnknown().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): TLRpcAnswerUnknown {
    return new TLRpcAnswerUnknown().fromJsonString(jsonString, options)
  }

  static equals(
    a: TLRpcAnswerUnknown | PlainMessage<TLRpcAnswerUnknown> | undefined,
    b: TLRpcAnswerUnknown | PlainMessage<TLRpcAnswerUnknown> | undefined
  ): boolean {
    return proto3.util.equals(TLRpcAnswerUnknown, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLRpcAnswerDroppedRunning
 */
export class TLRpcAnswerDroppedRunning extends Message<TLRpcAnswerDroppedRunning> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.RpcDropAnswer data2 = 1;
   */
  data2?: RpcDropAnswer

  constructor(data?: PartialMessage<TLRpcAnswerDroppedRunning>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.TLRpcAnswerDroppedRunning'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'data2', kind: 'message', T: RpcDropAnswer, opt: true },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): TLRpcAnswerDroppedRunning {
    return new TLRpcAnswerDroppedRunning().fromBinary(bytes, options)
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): TLRpcAnswerDroppedRunning {
    return new TLRpcAnswerDroppedRunning().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): TLRpcAnswerDroppedRunning {
    return new TLRpcAnswerDroppedRunning().fromJsonString(jsonString, options)
  }

  static equals(
    a: TLRpcAnswerDroppedRunning | PlainMessage<TLRpcAnswerDroppedRunning> | undefined,
    b: TLRpcAnswerDroppedRunning | PlainMessage<TLRpcAnswerDroppedRunning> | undefined
  ): boolean {
    return proto3.util.equals(TLRpcAnswerDroppedRunning, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLRpcAnswerDropped
 */
export class TLRpcAnswerDropped extends Message<TLRpcAnswerDropped> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.RpcDropAnswer data2 = 1;
   */
  data2?: RpcDropAnswer

  constructor(data?: PartialMessage<TLRpcAnswerDropped>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.TLRpcAnswerDropped'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'data2', kind: 'message', T: RpcDropAnswer, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLRpcAnswerDropped {
    return new TLRpcAnswerDropped().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLRpcAnswerDropped {
    return new TLRpcAnswerDropped().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): TLRpcAnswerDropped {
    return new TLRpcAnswerDropped().fromJsonString(jsonString, options)
  }

  static equals(
    a: TLRpcAnswerDropped | PlainMessage<TLRpcAnswerDropped> | undefined,
    b: TLRpcAnswerDropped | PlainMessage<TLRpcAnswerDropped> | undefined
  ): boolean {
    return proto3.util.equals(TLRpcAnswerDropped, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.RpcError
 */
export class RpcError extends Message<RpcError> {
  /**
   * @generated from field: optional string predicate_name = 1;
   */
  predicateName?: string

  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.TLConstructor constructor = 2;
   */
  constructor$?: TLConstructor

  /**
   * @generated from field: optional int32 error_code = 3;
   */
  errorCode?: number

  /**
   * @generated from field: optional string error_message = 4;
   */
  errorMessage?: string

  constructor(data?: PartialMessage<RpcError>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.RpcError'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'predicate_name', kind: 'scalar', T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: 'constructor', kind: 'enum', T: proto3.getEnumType(TLConstructor), opt: true },
    { no: 3, name: 'error_code', kind: 'scalar', T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 4, name: 'error_message', kind: 'scalar', T: 9 /* ScalarType.STRING */, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RpcError {
    return new RpcError().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RpcError {
    return new RpcError().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RpcError {
    return new RpcError().fromJsonString(jsonString, options)
  }

  static equals(
    a: RpcError | PlainMessage<RpcError> | undefined,
    b: RpcError | PlainMessage<RpcError> | undefined
  ): boolean {
    return proto3.util.equals(RpcError, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLRpcError
 */
export class TLRpcError extends Message<TLRpcError> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.RpcError data2 = 1;
   */
  data2?: RpcError

  constructor(data?: PartialMessage<TLRpcError>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.TLRpcError'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'data2', kind: 'message', T: RpcError, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLRpcError {
    return new TLRpcError().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLRpcError {
    return new TLRpcError().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLRpcError {
    return new TLRpcError().fromJsonString(jsonString, options)
  }

  static equals(
    a: TLRpcError | PlainMessage<TLRpcError> | undefined,
    b: TLRpcError | PlainMessage<TLRpcError> | undefined
  ): boolean {
    return proto3.util.equals(TLRpcError, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TlsBlock
 */
export class TlsBlock extends Message<TlsBlock> {
  /**
   * @generated from field: optional string predicate_name = 1;
   */
  predicateName?: string

  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.TLConstructor constructor = 2;
   */
  constructor$?: TLConstructor

  /**
   * @generated from field: optional string data = 3;
   */
  data?: string

  /**
   * @generated from field: optional int32 length = 4;
   */
  length?: number

  /**
   * @generated from field: optional int32 seed = 5;
   */
  seed?: number

  /**
   * @generated from field: repeated tech.monstrs.chats_system.core.v1alpha1.TlsBlock entries = 6;
   */
  entries: TlsBlock[] = []

  constructor(data?: PartialMessage<TlsBlock>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.TlsBlock'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'predicate_name', kind: 'scalar', T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: 'constructor', kind: 'enum', T: proto3.getEnumType(TLConstructor), opt: true },
    { no: 3, name: 'data', kind: 'scalar', T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: 'length', kind: 'scalar', T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 5, name: 'seed', kind: 'scalar', T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 6, name: 'entries', kind: 'message', T: TlsBlock, repeated: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TlsBlock {
    return new TlsBlock().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TlsBlock {
    return new TlsBlock().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TlsBlock {
    return new TlsBlock().fromJsonString(jsonString, options)
  }

  static equals(
    a: TlsBlock | PlainMessage<TlsBlock> | undefined,
    b: TlsBlock | PlainMessage<TlsBlock> | undefined
  ): boolean {
    return proto3.util.equals(TlsBlock, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLTlsBlockString
 */
export class TLTlsBlockString extends Message<TLTlsBlockString> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.TlsBlock data2 = 1;
   */
  data2?: TlsBlock

  constructor(data?: PartialMessage<TLTlsBlockString>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.TLTlsBlockString'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'data2', kind: 'message', T: TlsBlock, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLTlsBlockString {
    return new TLTlsBlockString().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLTlsBlockString {
    return new TLTlsBlockString().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLTlsBlockString {
    return new TLTlsBlockString().fromJsonString(jsonString, options)
  }

  static equals(
    a: TLTlsBlockString | PlainMessage<TLTlsBlockString> | undefined,
    b: TLTlsBlockString | PlainMessage<TLTlsBlockString> | undefined
  ): boolean {
    return proto3.util.equals(TLTlsBlockString, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLTlsBlockRandom
 */
export class TLTlsBlockRandom extends Message<TLTlsBlockRandom> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.TlsBlock data2 = 1;
   */
  data2?: TlsBlock

  constructor(data?: PartialMessage<TLTlsBlockRandom>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.TLTlsBlockRandom'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'data2', kind: 'message', T: TlsBlock, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLTlsBlockRandom {
    return new TLTlsBlockRandom().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLTlsBlockRandom {
    return new TLTlsBlockRandom().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLTlsBlockRandom {
    return new TLTlsBlockRandom().fromJsonString(jsonString, options)
  }

  static equals(
    a: TLTlsBlockRandom | PlainMessage<TLTlsBlockRandom> | undefined,
    b: TLTlsBlockRandom | PlainMessage<TLTlsBlockRandom> | undefined
  ): boolean {
    return proto3.util.equals(TLTlsBlockRandom, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLTlsBlockZero
 */
export class TLTlsBlockZero extends Message<TLTlsBlockZero> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.TlsBlock data2 = 1;
   */
  data2?: TlsBlock

  constructor(data?: PartialMessage<TLTlsBlockZero>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.TLTlsBlockZero'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'data2', kind: 'message', T: TlsBlock, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLTlsBlockZero {
    return new TLTlsBlockZero().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLTlsBlockZero {
    return new TLTlsBlockZero().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLTlsBlockZero {
    return new TLTlsBlockZero().fromJsonString(jsonString, options)
  }

  static equals(
    a: TLTlsBlockZero | PlainMessage<TLTlsBlockZero> | undefined,
    b: TLTlsBlockZero | PlainMessage<TLTlsBlockZero> | undefined
  ): boolean {
    return proto3.util.equals(TLTlsBlockZero, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLTlsBlockDomain
 */
export class TLTlsBlockDomain extends Message<TLTlsBlockDomain> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.TlsBlock data2 = 1;
   */
  data2?: TlsBlock

  constructor(data?: PartialMessage<TLTlsBlockDomain>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.TLTlsBlockDomain'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'data2', kind: 'message', T: TlsBlock, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLTlsBlockDomain {
    return new TLTlsBlockDomain().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLTlsBlockDomain {
    return new TLTlsBlockDomain().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLTlsBlockDomain {
    return new TLTlsBlockDomain().fromJsonString(jsonString, options)
  }

  static equals(
    a: TLTlsBlockDomain | PlainMessage<TLTlsBlockDomain> | undefined,
    b: TLTlsBlockDomain | PlainMessage<TLTlsBlockDomain> | undefined
  ): boolean {
    return proto3.util.equals(TLTlsBlockDomain, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLTlsBlockGrease
 */
export class TLTlsBlockGrease extends Message<TLTlsBlockGrease> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.TlsBlock data2 = 1;
   */
  data2?: TlsBlock

  constructor(data?: PartialMessage<TLTlsBlockGrease>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.TLTlsBlockGrease'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'data2', kind: 'message', T: TlsBlock, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLTlsBlockGrease {
    return new TLTlsBlockGrease().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLTlsBlockGrease {
    return new TLTlsBlockGrease().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLTlsBlockGrease {
    return new TLTlsBlockGrease().fromJsonString(jsonString, options)
  }

  static equals(
    a: TLTlsBlockGrease | PlainMessage<TLTlsBlockGrease> | undefined,
    b: TLTlsBlockGrease | PlainMessage<TLTlsBlockGrease> | undefined
  ): boolean {
    return proto3.util.equals(TLTlsBlockGrease, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLTlsBlockPublicKey
 */
export class TLTlsBlockPublicKey extends Message<TLTlsBlockPublicKey> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.TlsBlock data2 = 1;
   */
  data2?: TlsBlock

  constructor(data?: PartialMessage<TLTlsBlockPublicKey>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.TLTlsBlockPublicKey'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'data2', kind: 'message', T: TlsBlock, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLTlsBlockPublicKey {
    return new TLTlsBlockPublicKey().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLTlsBlockPublicKey {
    return new TLTlsBlockPublicKey().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): TLTlsBlockPublicKey {
    return new TLTlsBlockPublicKey().fromJsonString(jsonString, options)
  }

  static equals(
    a: TLTlsBlockPublicKey | PlainMessage<TLTlsBlockPublicKey> | undefined,
    b: TLTlsBlockPublicKey | PlainMessage<TLTlsBlockPublicKey> | undefined
  ): boolean {
    return proto3.util.equals(TLTlsBlockPublicKey, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLTlsBlockScope
 */
export class TLTlsBlockScope extends Message<TLTlsBlockScope> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.TlsBlock data2 = 1;
   */
  data2?: TlsBlock

  constructor(data?: PartialMessage<TLTlsBlockScope>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.TLTlsBlockScope'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'data2', kind: 'message', T: TlsBlock, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLTlsBlockScope {
    return new TLTlsBlockScope().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLTlsBlockScope {
    return new TLTlsBlockScope().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLTlsBlockScope {
    return new TLTlsBlockScope().fromJsonString(jsonString, options)
  }

  static equals(
    a: TLTlsBlockScope | PlainMessage<TLTlsBlockScope> | undefined,
    b: TLTlsBlockScope | PlainMessage<TLTlsBlockScope> | undefined
  ): boolean {
    return proto3.util.equals(TLTlsBlockScope, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TlsClientHello
 */
export class TlsClientHello extends Message<TlsClientHello> {
  /**
   * @generated from field: optional string predicate_name = 1;
   */
  predicateName?: string

  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.TLConstructor constructor = 2;
   */
  constructor$?: TLConstructor

  /**
   * @generated from field: repeated tech.monstrs.chats_system.core.v1alpha1.TlsBlock blocks = 3;
   */
  blocks: TlsBlock[] = []

  constructor(data?: PartialMessage<TlsClientHello>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.TlsClientHello'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'predicate_name', kind: 'scalar', T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: 'constructor', kind: 'enum', T: proto3.getEnumType(TLConstructor), opt: true },
    { no: 3, name: 'blocks', kind: 'message', T: TlsBlock, repeated: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TlsClientHello {
    return new TlsClientHello().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TlsClientHello {
    return new TlsClientHello().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TlsClientHello {
    return new TlsClientHello().fromJsonString(jsonString, options)
  }

  static equals(
    a: TlsClientHello | PlainMessage<TlsClientHello> | undefined,
    b: TlsClientHello | PlainMessage<TlsClientHello> | undefined
  ): boolean {
    return proto3.util.equals(TlsClientHello, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLTlsClientHello
 */
export class TLTlsClientHello extends Message<TLTlsClientHello> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.TlsClientHello data2 = 1;
   */
  data2?: TlsClientHello

  constructor(data?: PartialMessage<TLTlsClientHello>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.TLTlsClientHello'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'data2', kind: 'message', T: TlsClientHello, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLTlsClientHello {
    return new TLTlsClientHello().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLTlsClientHello {
    return new TLTlsClientHello().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLTlsClientHello {
    return new TLTlsClientHello().fromJsonString(jsonString, options)
  }

  static equals(
    a: TLTlsClientHello | PlainMessage<TLTlsClientHello> | undefined,
    b: TLTlsClientHello | PlainMessage<TLTlsClientHello> | undefined
  ): boolean {
    return proto3.util.equals(TLTlsClientHello, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.HelpConfigSimple
 */
export class HelpConfigSimple extends Message<HelpConfigSimple> {
  /**
   * @generated from field: optional string predicate_name = 1;
   */
  predicateName?: string

  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.TLConstructor constructor = 2;
   */
  constructor$?: TLConstructor

  /**
   * @generated from field: optional int32 date = 3;
   */
  date?: number

  /**
   * @generated from field: optional int32 expires = 4;
   */
  expires?: number

  /**
   * @generated from field: repeated tech.monstrs.chats_system.core.v1alpha1.AccessPointRule rules = 5;
   */
  rules: AccessPointRule[] = []

  constructor(data?: PartialMessage<HelpConfigSimple>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.HelpConfigSimple'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'predicate_name', kind: 'scalar', T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: 'constructor', kind: 'enum', T: proto3.getEnumType(TLConstructor), opt: true },
    { no: 3, name: 'date', kind: 'scalar', T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 4, name: 'expires', kind: 'scalar', T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 5, name: 'rules', kind: 'message', T: AccessPointRule, repeated: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HelpConfigSimple {
    return new HelpConfigSimple().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HelpConfigSimple {
    return new HelpConfigSimple().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HelpConfigSimple {
    return new HelpConfigSimple().fromJsonString(jsonString, options)
  }

  static equals(
    a: HelpConfigSimple | PlainMessage<HelpConfigSimple> | undefined,
    b: HelpConfigSimple | PlainMessage<HelpConfigSimple> | undefined
  ): boolean {
    return proto3.util.equals(HelpConfigSimple, a, b)
  }
}

/**
 * @generated from message tech.monstrs.chats_system.core.v1alpha1.TLHelpConfigSimple
 */
export class TLHelpConfigSimple extends Message<TLHelpConfigSimple> {
  /**
   * @generated from field: optional tech.monstrs.chats_system.core.v1alpha1.HelpConfigSimple data2 = 1;
   */
  data2?: HelpConfigSimple

  constructor(data?: PartialMessage<TLHelpConfigSimple>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = 'tech.monstrs.chats_system.core.v1alpha1.TLHelpConfigSimple'
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'data2', kind: 'message', T: HelpConfigSimple, opt: true },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLHelpConfigSimple {
    return new TLHelpConfigSimple().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLHelpConfigSimple {
    return new TLHelpConfigSimple().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): TLHelpConfigSimple {
    return new TLHelpConfigSimple().fromJsonString(jsonString, options)
  }

  static equals(
    a: TLHelpConfigSimple | PlainMessage<TLHelpConfigSimple> | undefined,
    b: TLHelpConfigSimple | PlainMessage<TLHelpConfigSimple> | undefined
  ): boolean {
    return proto3.util.equals(TLHelpConfigSimple, a, b)
  }
}
